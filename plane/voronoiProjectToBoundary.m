%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input:
%   DT  :   delaunayTriangulation object with N generators
%   U   :   Nx2 double array where each row represents the projection
%           vector for the corresponding generator. Each row is assumed to 
%           have unit norm.
% Output:
%   Q   :   Nx2 double array. Row i are the coordinates of the projection
%           of generator i along direction U(i,:) onto the boundary of the
%           Voronoi cell generated by i. 
%   r   :   Nx1 double column vector. r(i) is the distance beween generator
%           i and the projected point Q(i,:). 
%   E   :   mx3 double array where m is the number of generators in the
%           convex hull of DT. The i-th row of E represents the unbounded
%           edge e which comes in counterclockwise from infinity of the
%           Voronoi cell whose generator is the i-th element of
%           convexHull(DT). Specifically, E(i,1) and E(i,2) are the x and y
%           coordinates of the (finite) vertex of e and E(i,3) is the angle
%           in [-pi,pi] at which e radiates to infinity.
%
% NOTES:
%   - If the ray intersects the Voronoi boundary only at infinity, then
%     Q(i,:) is set to [Inf Inf] and r(i) to Inf.
%   - All computations are numerical. In particular, this may result in
%     significant error in the intersections point calculation when U(i,:) 
%     is nearly parallel to an unbounded edge of the corresponding Voronoi
%     cell.
%   - The third output E is useful primarily for plotting the Voronoi
%     diagram with its unbounded edges. The elements of E are necessary in
%     computation of Q and r so no unecessary calculation is being
%     performed is E is omitted.

function [Q,r,E] = voronoiProjectToBoundary(DT, U)

arguments
    DT delaunayTriangulation
    U (:,2) double {mustBeCompatible(U,DT)}
end

X = DT.Points;
N = size(X,1);

Q = zeros(N,2);
r = zeros(N,1);

CH = convexHull(DT);
[V,C] = voronoiDiagram(DT);

bounds = [min([V; X],[],1) max([V(2:end,:); X],[],1)];    % [xmin ymin xmax ymax] among generators and (bounded) Voronoi vertices
L = 2*(bounds(3)-bounds(1) + bounds(4)-bounds(2));      % L > distance from any generator to any finite Voronoi vertex

%% Computes the direction each unbounded Voronoi edge radiates from its bounded vertex
%  unbd_edge_arg(i) stores the direction of the Voronoi edge between the
%  i-th and (i+1)-st generators on the convex hull, i.e., CH(i) and
%  CH(i+1), as (floating point) number in [0,2pi). 

[~,X_bd] = freeBoundary(DT);
d = circshift(X_bd,-1,1) - X_bd;
unbd_edge_arg = atan2(d(:,2),d(:,1))-pi/2;
unbd_edge_arg = unbd_edge_arg + 2*pi*(unbd_edge_arg < -pi);

%% Compute intersections for interior generators

IN = setdiff(1:N, CH)';  % indices of interior generators
for l = 1:size(IN)
    i = IN(l);
    a = atan2(U(i,2),U(i,1));
    rayx = [ X(i,1) X(i,1)+L*cos(a) ];
    rayy = [ X(i,2) X(i,2)+L*sin(a) ];
    c = V(C{IN(l)},:);
    c_close = [c; c(1,:)];
    [xi,yi] = polyxpoly(rayx,rayy,c_close(:,1),c_close(:,2));
    Q(i,:) = [xi yi];
    r(i) = norm( X(i,:) - [xi yi] );
end

%% Compute intersections for boundary generators

m = size(CH,1)-1;
E = zeros(m,3);

for l = 1:m
    i = CH(l);
    c = V(C{i},:);  
    a = atan2(U(i,2),U(i,1));
    a1 = unbd_edge_arg(l);
    a2 = atan2(c(2,2)-X(i,2), c(2,1)-X(i,1));
    a3 = atan2(c(end,2)-X(i,2), c(end,1)-X(i,1));
    a4 = unbd_edge_arg(1+mod(l-2,m));
    [~,S] = sort([a,a1,a2,a3,a4]);
    S = circshift(S, 1-find(S==1));
    switch S(2)
        case 2  % intersect Voronoi boundary at infinity
            xi = Inf; yi = Inf;
        case 3  % intersect unbounded edge counterclockwise incoming from infinity
            p = c(2,:);
%             t = ( U(i,1)*(p(2)-X(i,2)) - U(i,2)*(p(1)-X(i,1)) );
%             t = t/(U(i,2)*cos(a1) - U(i,1)*sin(a1));
            d = p-X(i,:);
            b = atan2(d(2),d(1));
            h = atan2(U(i,2),U(i,1));
            t = -norm(d)*sin(h-b)*csc(h-a1);
            xi = p(1) + t*cos(a1);
            yi = p(2) + t*sin(a1);
        case 4  % intersect bounded edge
            rayx = [ X(i,1) X(i,1)+L*cos(a) ];
            rayy = [ X(i,2) X(i,2)+L*sin(a) ];
            [xi,yi] = polyxpoly(rayx,rayy,c(2:end,1),c(2:end,2));
        case 5  % intersect unbounded edge counterclockwise outgoing to infinity
            p = c(end,:);
%             t = ( U(i,1)*(p(2)-X(i,2)) - U(i,2)*(p(1)-X(i,1)) );
%             t = t/(U(i,2)*cos(a4) - U(i,1)*sin(a4));
            d = p-X(i,:);
            b = atan2(d(2),d(1));
            h = atan2(U(i,2),U(i,1));
            t = -norm(d)*sin(h-b)*csc(h-a4);
            xi = p(1) + t*cos(a4);
            yi = p(2) + t*sin(a4);
   end
    Q(i,:) = [xi yi];
    r(i) = norm( Q(i,:) - X(i,:) );
    E(l,:) = [ c(2,:) a1 ];
end

end

% validation
function mustBeCompatible(U,DT)
    if size(U,1) ~= size(DT.Points,1)
        eid = 'Size:notEqual';
        msg = 'Number of rows of second input must match the number of points in the triangulation.';
        throwAsCaller(MException(eid,msg));
    end
end